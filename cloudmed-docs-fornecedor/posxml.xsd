<?xml version="1.0" encoding="utf-8"?>
<xs:schema targetNamespace="http://tempuri.org/posxml.xsd" elementFormDefault="qualified" xmlns="http://tempuri.org/posxml.xsd" xmlns:mstns="http://tempuri.org/posxml.xsd" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:element name="aplicativoposxml">
    <xs:annotation>
      <xs:documentation>Aplicativo PosXML.</xs:documentation>
    </xs:annotation>
    <xs:complexType>
      <xs:sequence>
        <xs:element name="pagina" type="pagina" maxOccurs="unbounded">
          <xs:annotation>
            <xs:documentation>Página de um aplicativo PosXML.</xs:documentation>
          </xs:annotation>
        </xs:element>
      </xs:sequence>
    </xs:complexType>
  </xs:element>
  <xs:complexType name="pagina">
    <xs:choice maxOccurs="unbounded">
      <xs:group ref="comandos" />
    </xs:choice>
    <xs:attribute name="nome" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome da página de um aplicativo PosXML. Coloque o nome de 'principal' para que esta seja a primeira página executada pelo terminal.</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:group name="comandos">
    <xs:choice>
      <xs:element name="display" type="display">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>linha,coluna,mensagem</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>d;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando display é usado para exibir no visor (display) do terminal POS uma mensagem específica na posição linha e coluna.</xs:documentation>
					<xs:example>&lt;display linha="1" coluna="1" mensagem="POSXML" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="limpadisplay" type="limpadisplay">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>H;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando limpadisplay é usado para apagar todas as mensagens exibidas no visor (display) do terminal POS.</xs:documentation>
					<xs:example>&lt;limpadisplay /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="if" type="if" maxOccurs="unbounded">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavel,operador,valor</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>I;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>E;false;false;false</xs:appinfo>
          <xs:documentation>A instrução if é um termo utilizado para especificar uma tomada de decisão ou comparação lógica dentro do programa POSXML. Outros comandos e instruções podem ser contidos dentro do argumento if e /if. Os comandos e instruções dentro do argumento são executados caso a expressão seja verdadeira.
            A instrução processa a operação entre variavel e o valor especificado, e entra na execução da próxima instrução dentro de if, caso seja verdadeiro o resultado.
            Todos os operadores (igual/diferente/maior/menor/maiorigual/menorigual) no caso de variável inteiro realizam as operações padrões de comparação de qualquer linguagem de programação.
            Já os operadores (maior/menor/maiorigual/menorigual) no caso de variável string, converterá a variável para ponto flutuante e realizarão a comparação. Os operadores (igual/diferente) seguem a mesma lógica de comparação de qualquer linguagem de programação.</xs:documentation>
					<xs:example>&lt;if variavel="$(TipoServico)" operador="igual" valor="1"&gt;
  &lt;guardavariavel variavel="$(TipoServico)" /&gt;
  &lt;pegacartao primeiramensagem="1. Cartao ou (OK)" segundamensagem="Digite Cartao:" minimo="15" maximo="16" /&gt;
  &lt;conectar /&gt;
&lt;/if&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="funcao" type="funcao" maxOccurs="unbounded">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nome</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>l;true;true;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>r;false;false;false</xs:appinfo>
          <xs:documentation>A instrução funcao é responsável por nomear uma função ou bloco de código contendo outras instruções, comandos e regras lógicas. Não podemos declarar blocos de funções dentro de funções. A execução da função só se dará , após a chamada pela instrução chamafuncao</xs:documentation>
					<xs:example>&lt;funcao nome="imprime_cupom"&gt;
  &lt;imprimagrande mensagem="Plano Be" /&gt;
  &lt;imprimagrande mensagem="CloudWalk" /&gt;
  &lt;paperfeed /&gt;
&lt;/funcao&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="digitainteiro" type="digitainteiro">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavel,linha,coluna,mensagem,minimo,maximo</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>i;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando digitainteiro permite a digitação de dados numéricos através do teclado do terminal POS. Uma mensagem é exibida no visor do terminal em linha e coluna especificadas e este fica aguardando a digitação da informação solicitada. Pode se configurar os intervalos mínimo e máximo do valor numérico digitado, que por sua vez é armazenado em variável de memória do terminal POS.</xs:documentation>
					<xs:example>&lt;digitainteiro linha="1" coluna="1" mensagem="Digite CEP:" variavel="$(CEP)" minimo="0" maximo="999999" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="digitaopcao" type="digitaopcao">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavel,linha,coluna,mensagem,minimo,maximo</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>o;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Praticamente a mesma instrução que digitainteiro com a diferença que ao digitarmos o número máximo especificado na instrução, a instrução automaticamente pula para a próxima , como que se estivéssemos pressionado enter ou OK.</xs:documentation>
					<xs:example>&lt;digitaopcao linha="0" coluna="0" mensagem="Digite a opcao:" variavel="$(Var)" minimo="0" maximo="9" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="digitavalor" type="digitavalor">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavel,linha,coluna,mensagem</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>y;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando digitavalor aguarda o operador do terminal digitar um valor monetário através do teclado do terminal. Exibe uma mensagem em linha e coluna especificadas. O valor digitado é armazenado em uma variável de memória do terminal POS. Possui máscara automática de pontos e vírgulas que vai mostrando automaticamente com pontos e vírgulas o valor digitado sem necessidade do operador digitar . (ponto) e , (virgula)
            O valor armazenado na variável é do tipo inteiro e não contem pontos nem vírgulas. O valor armazenado ficará assim, seguindo a especificação ISO8583 para valores.
            1 = 1 centavo
            10 = 10 centavos
            100 = 1 real
            1000 = 10 reais
            10000 = 100 reais
            100000 = 1000 reais
            1000000 = 10000 reais</xs:documentation>
					<xs:example>&lt;digitavalor linha="1" coluna="1" mensagem="Valor da Compra:" variavel="$(valor)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="digitaformato" type="digitaformato">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavel,linha,coluna,mensagem,formato</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>f;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando digitaformato aguarda o operador do terminal digitar uma informação que tenha formato específico ou máscara de entrada. Exibe uma mensagem em linha e coluna especificadas. A informação digitada no teclado do terminal é então armazenada em memória.</xs:documentation>
					<xs:example>&lt;digitaformato linha="1" coluna="1" mensagem="Data da compra:" variavel="$(Data)" formato="99/99/9999" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="imprima" type="imprima">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>mensagem</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>p;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando imprima envia para a impressora do terminal uma mensagem especificada e que por sua vez é impressa em papel. Independente da impressora ser térmica, matricial de impacto, etc. A impressão é feita com tamanho de fonte dupla, ou seja, duas vezes maior que o tamanho normal. Já a instrução imprima,  imprime com um tamanho de fonte normal.</xs:documentation>
					<xs:example>&lt;imprima mensagem="Tecnologia" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="imprimagrande" type="imprimagrande">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>mensagem</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>P;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando imprimagrande envia para a impressora do terminal uma mensagem especificada e que por sua vez é impressa em papel. Independente da impressora ser térmica, matricial de impacto, etc. A impressão é feita com tamanho de fonte dupla, ou seja, duas vezes maior que o tamanho normal. Já a instrução imprima,  imprime com um tamanho de fonte normal.</xs:documentation>
					<xs:example>&lt;imprimagrande mensagem="Plano Be" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="paperfeed" type="paperfeed">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>h;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando paperfeed envia para a impressora do terminal POS um comando para que o papel salte várias linhas até o necessário suficiente para que seja destacado sem cortar o conteúdo impresso.</xs:documentation>
          <xs:example>&lt;paperfeed /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="digitadecimal" type="digitadecimal">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavel,linha,coluna,mensagem</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>s;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando digitadecimal aguarda o operador do terminal digitar um valor com ponto (.)  através do teclado do terminal utilizando a tecla * para inserir o ponto. Exibe uma mensagem em linha e coluna especificadas. O valor digitado é armazenado em uma variável string de memória do terminal POS, incluindo o ponto.</xs:documentation>
					<xs:example>&lt;variavelstr valor="1.00" variavel="valor" /&gt;
&lt;digitadecimal variavel="$(valor)" linha="1" coluna="1" mensagem="Kilogramas:" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="conectar" type="conectar">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>M;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando conectar prepara o dispositivo de conexão, seja um modem analógico ou não, e envia todas as informações coletadas pelo operador até o sistema atendedor e que irá receber tais informações coletadas.</xs:documentation>
					<xs:example>&lt;conectar /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="preconexao" type="preconexao">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelstatus</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>S;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando preconexao inicializa o dispositivo de conexão e retorna na variável especificada se conseguiu conectar no host ou não. Se a variável for igual a -1 , ocorreu um erro de conexão. Se a variável for igual a 0 o terminal está conectado ao host. Lembrando que está instrução não envia nenhuma informação ao host, apenas faz a conexão. Para enviar as variáveis coletadas devemos chamar a instrução conectar.</xs:documentation>
          <xs:example>&lt;variavelint valor="-1" variavel="iConectado" /&gt;
 
&lt;preconexao variavelstatus="$(iConectado)" /&gt;
 
&lt;if variavel="$(iConectado)" operador="igual" valor="-1"&gt;
   &lt;display linha="0" coluna="0" mensagem=" Erro de conexao" /&gt;
&lt;/if&gt;
 
&lt;if variavel="$(iConectado)" operador=" igual" valor="0"&gt;
   &lt;display linha="0" coluna="0" mensagem=" Conectado ..." /&gt;
   &lt;esperatecla /&gt;
&lt;/if&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="desligamodem" type="desligamodem">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>D;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando desligamodem cancela as operações do dispositivo de conexão, encerrando a conexão aberta com o host (atendedor) e desliga o modem.</xs:documentation>
					<xs:example>&lt;desligamodem /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="pegacartao" type="pegacartao">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>primeiramensagem,segundamensagem,minimo,maximo</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>c;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando pegacartao fica aguardando o operador do terminal POS passar um cartão magnético em sua leitora de trilhas ou a digitação dos números de um determinado cartão. Pode exibir duas mensagens, uma para ser exibida quando o terminal pedir que o operador passe o cartão na leitora e a outra para ser exibida quando o operador pede para digitar o cartão. Pode-se determinar o número mínimo e máximo de bytes que podem ser digitados. O conteúdo do cartão digitado ou capturado da tarja magnética é armazenado na memória que vai ser enviada ao host com a seguinte sintaxe : &lt;cartao&gt;00000000000000000 se foi passado ou &lt;cartao&gt;D0000000000000000 se foi digitado. É possível também usar esta instrução com um cartão EMV, caso o cartão passado seja um cartão com chip a instrução 'emv.inittransaction' será executada.</xs:documentation>
          <xs:example>&lt;pegacartao primeiramensagem="Passe cartao ou tecle OK" segundamensagem="Digite cartão com 16 digitos" minimo="16" maximo="16" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="pegacartaoevariavel" type="pegacartaoevariavel">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>primeiramensagem,segundamensagem,minimo,maximo,variavel</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>k;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando pegacartaovariavel fica aguardando o operador do terminal POS passar um cartão magnético em sua leitora de trilhas ou a digitação dos números de um determinado cartão. Pode exibir duas mensagens, uma para ser exibida quando o terminal pedir que o operador passe o cartão na leitora e a outra para ser exibida quando o operador pede para digitar o cartão. Pode-se determinar o número mínimo e máximo de bytes que podem ser digitados. O conteúdo do cartão digitado ou capturado da tarja magnética é armazenado na variável especificada. Se foi digitado o primeiro caractere da variável vai ser ‘D’. É possível também usar esta instrução com um cartão EMV, caso o cartão passado seja um cartão com chip a instrução 'emv.inittransaction' será executada.</xs:documentation>
          <xs:example>&lt;pegacartaoevariavel primeiramensagem="Passe o cartao ou tecle OK" segundamensagem="Digite o Cartao:" minimo="4" maximo="40" variavel="$(PIN)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="imprimalogo" type="imprimalogo">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>index</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>q;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando imprima logo , imprimi um logo em um formato especificado que está na memória do terminal.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="esperatecla" type="esperatecla">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>u;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando esperatecla aguarda o operador do terminal pressionar qualquer tecla no terminal para continuar alguma operação.</xs:documentation>
					<xs:example>&lt;esperatecla /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="espera" type="espera">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>milisegundos</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>C;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando espera aguarda o tempo especificado em milisegundos até que possa continuar com a execução do programa. O aplicativo aguardará o tempo especificado mesmo que operador pressione qualquer tecla.</xs:documentation>
					<xs:example>&lt;espera milisegundos="1000" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="guardavariavel" type="guardavariavel">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavel</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>F;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>A instrução guardavariavel é um termo de atribuição, responsável pelo armazenamento e enfileiramento do conteúdo de uma variável para ser enviado ao host (atendedor). O conteúdo é armazenado em memória do Terminal POS, sendo que cada vez que chamamos a instrução guarda variável , o conteúdo da variável é guardado em um buffer e separado por virgula. Ao chamarmos a instrução conectar , o terminal envia o buffer completo para o host.</xs:documentation>
					<xs:example>&lt;guardavariavel variavel="$(numeroCartao)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="limpavariaveis" type="limpavariaveis">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>z;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>A instrução limpavariaveis é um comando que apaga o conteúdo da variável que contém o buffer a ser enviado ao host. O buffer separado por ‘,’ montado por guardavariavel é limpo ao chamarmos esta instrução.</xs:documentation>
					<xs:example>&lt;limpavariaveis /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="chamafuncao" type="chamafuncao">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nome</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>g;true;true;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>A instrução chamafuncao é um termo de desvio e é responsável por fazer uma chamada e executar uma função contendo um bloco de comandos, conforme descrito acima.</xs:documentation>
					<xs:example>&lt;chamafuncao nome="imprime_cupom" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="variavelint" type="variavelint">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>valor,variavel</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>m;true;false;true</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>A instrução variavelint é um termo de atribuição e serve para armazenar um determinado valor numérico e inteiro em uma variável especificada.</xs:documentation>
          <xs:example>&lt;ariavelint valor="1" variavel="Parcelas" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="variavelstr" type="variavelstr">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>valor,variavel</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>&gt;;true;false;true</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>A instrução variavelstr é um termo de atribuição e serve para armazenar um determinado valor alfanumérico (que contenha letras e números) em uma variável especificada.</xs:documentation>
          <xs:example>&lt;ariavelstr valor="Plano Bê" variavel="Nome" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="substring" type="substring">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>posicao,variavelorigem,variaveldestino,caracter,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>&lt;;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>A instrução substring é a instrução responsável por copiar um trecho de uma variável origem do tipo "string" para uma variável também do tipo string.</xs:documentation>
          <xs:example>&lt;substring posicao="1" variavelorigem="$(ContemTudo)" variaveldestino="$(ContemParte)" caracter="," variavelretorno="$(ret)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="stringtoint" type="stringtoint">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelstr,variavelint</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>a;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>A instrução stringtoint é a função responsável por converter o conteúdo de variáveis do tipo string para o tipo inteiro, convertendo sempre a string especificada até o primeiro caracter não númerico. A conversão é feita e o conteúdo convertido é armazenado então em uma outra variável do tipo inteiro.</xs:documentation>
          <xs:example>&lt;stringtoint variavelstr="$(ValorStr)" variavelint="$(ValorInteiro)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="inttostring" type="inttostring">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelint,variavelstr</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>b;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>A instrução inttostring é a função responsável por converter o conteúdo de variáveis do tipo inteiro para o tipo string. A conversão é feita e o conteúdo convertido é armazenado então em uma outra variável do tipo string.</xs:documentation>
					<xs:example>&lt;inttostring variavelint="$(ValorInteiro)" variavelstr="$(ValorStr)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.getvaluebykey" type="string.getvaluebykey">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>string,chave,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>K;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>A instrução string.getvaluebykey procura em uma string por um valor baseado em key/value. </xs:documentation>
          <xs:example>&lt;string.getvaluebykey chave="valor" string="$(sStringDeLeitura)" variavelretorno="$(sStringDeResposta)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="menu" type="menu">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavel,opcoes</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>L;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>A instrução menu constrói um menu na tela do terminal , conforme o número de linhas do mesmo. Na constante string opções para cada barra ‘\’ existente, vai ser uma quebra de linha. A primeira opção antes da primeira barra será o titulo do menu e estará em todas as telas mesmo rolando para mais opções. Quando o numero de opções atinge o tamanho maximo do numero de linhas , vai aparecer ao lado do titulo um sinal de ‘+’ indicando que é possível rolar para outra tela.É possível mostrar a outra tela , pressionado (enter, ou OK).
            O usuário pode digitar de 0 a 9, ou seja , temos a possibilidade de ter 10 opções de menu. O valor digitado fica armazenado em variavel.</xs:documentation>
					<xs:example>&lt;menu variavel="$(var1)" opcoes="MENU\1. primeira linha\2. segunda linha 2 \3. terceira linha"/&gt;
&lt;if variavel="$(var1)" operador="igual" valor="2"&gt;
  &lt;display linha="0" coluna="0" mensagem="Segunda Opcao" /&gt;
  &lt;esperatecla /&gt;
&lt;/if&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="menuwithheader" type="menuwithheader">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>header,options,timeoutheader,timeout,variablereturn</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x81;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>A instrução menuwithheader constrói um menu na tela do terminal, conforme o número de linhas do mesmo. Na constante string opções para cada barra ‘\’ existente, vai ser uma quebra de linha. O cabeçalho será quebrado em "|" e mostrado na primeira linha atualizando baseado no tempo definido em timeouttitulo. Quando o numero de opções atinge o tamanho maximo do numero de linhas , vai aparecer ao lado do titulo um sinal de ‘+’ indicando que é possível rolar para outra tela.É possível mostrar a outra tela , pressionado (enter, ou OK).
            O usuário pode digitar qualquer key. O valor digitado fica armazenado em variavel. Quando estourar o timeout retornara "-1". A chave de config.dat iskeytimeout deve ser 1.</xs:documentation>
					<xs:example>&lt;menuwithheader header="Bem Vindo|d/M/yy h:m:s|d/M/yy h:m:s|h:m:s MENU|h:m:s AA|BB"
timeoutheader="1" options="1.Opcao A\2.Opcao B\3.Opcao C\4.AA\5.BB\6.CC\7.DD\8.EE\9.FF"
timeout="30" variablereturn="$(sMenu)"/&gt;
&lt;imprima mensagem="$(sMenu)"/&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="learquivo" type="learquivo">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nomearquivo,chave,variaveldestino</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>B;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite ler um arquivo no formato WALK dbfile (‘chave=valor\nchave=valor\n’).Se por algum motivo o arquivo não existir, o nome da chave não existir no arquivo, ou qualquer outro erro no sistema de arquivos, vardestino será completado com um espaço em branco (‘ ‘).
            Pode-se ler arquivos criados por instruções PosXML ou mesmo arquivos criados em outros programas e carregados no terminal de alguma maneira, desde que sigam o formato citado.</xs:documentation>
					<xs:example>	&lt;variavelstr valor="config.dat" variavel="filename" /&gt;
&lt;variavelstr valor="senhatecnica" variavel="key" /&gt;
&lt;variavelstr valor=" " variavel="buffer" /&gt;
&lt;learquivo nomearquivo="$(filename)" chave=$(key)" variaveldestino="$(buffer)" /&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="editaarquivo" type="editaarquivo">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nomearquivo,chave,valor</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>A;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite escrever um arquivo no formato WALK dbfile (‘chave=valor\nchave=valor\n’).</xs:documentation>
					<xs:example>&lt;variavelstr valor="config.dat" variavel="filename" /&gt;
&lt;variavelstr valor="senhatecnica" variavel="key" /&gt;
&lt;variavelstr valor="12345 " variavel="buffer" /&gt;
&lt;editaarquivo nomearquivo="$(filename)" chave="$(key)" valor="$(buffer)" /&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="variavelintoperador" type="variavelintoperador">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>operador,variavelorigem</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>G;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite adicionar +1 ou decrementar -1 na variável inteiro especificado em varorigem. Muito útil em situações que desejamos utilizar laços ou fazer contadores.</xs:documentation>
          <xs:example>&lt;variavelint valor="0" variável="$(counter)" /&gt;
&lt;ariavelintoperador operador="++" variavelorigem="$(counter)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="ajustadatahora" type="ajustadatahora">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>datahora</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>J;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite atualizar o relógio interno do terminal. Devemos passar o ano, mês, dia , hora, minuto , segundo ‘datahora’ no formato ‘yyyyMMddhhmmss’.</xs:documentation>
					<xs:example>&lt;ajustadatahora datahora="20121221235959" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="pegadatahora" type="pegadatahora">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>formato,variaveldestino</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>n;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite colocar o valor de data/hora atuais na variável string , variaveldestino , no formato especificado em formato.
            Em formato, qualquer caractere de formatação de data vai ser substituído pelo valor do relógio do terminal. Os caracteres reservados para formatação de data são:
            yy: Ano com 4 dígitos
            y: Ano com 2 dígitos
            M: mês com 2 dígitos
            d: dia com 2 dígitos
            h: hora com 2 dígitos
            m: minuto com 2 dígitos
            s: segundos com 2 dígitos</xs:documentation>
            <xs:example>&lt;variavelstr valor=" " variavel="buffer" /&gt;
&lt;pegadatahora formato="Data Hoje : d/M/yy h:m:s" variaveldestino="$(buffer)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="verificapapelimpressora" type="verificapapelimpressora">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelresultado</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>N;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite verificar se o compartimento de papel ainda contém papel. Útil para avisar quando o papel acabou e não deixar o operador prosseguir com a operação, enquanto não trocar o papel. Se ainda houver papel no compartimento variavelresultado será igual a 1. Se o papel acabou variavelresultado ficará com o valor 0.</xs:documentation>
          <xs:example>&lt;variavelint valor="-1" variável="temPapel" /&gt;
&lt;verificapapelimpressora variavelresultado="$(temPapel)" /&gt;
 
&lt;if variavel="$(temPapel)" operador="igual" valor="0"&gt;
  &lt;display linha="0" coluna="0" mensagem=" Sem papel " /&gt;
&lt;/if&gt;
 
&lt;if variavel="$(temPapel)" operador="igual" valor="1"&gt;
  &lt;display linha="0" coluna="0" mensagem=" Possui papel " /&gt;
&lt;/if&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="ultimapagina" type="ultimapagina">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>R;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite recarregar e executar a última pagina de comandos recebido pelo terminal, enviados pelo host. Esta última página sempre fica armazenada na memória do terminal até que se desligue o mesmo. Quando chamada, está instrução executa a última pagina, e em seguida a execução do walk termina. Muito útil, para escrevermos lógicas de reimpressão caso a ultima pagina seja um ticket enviado para o terminal.</xs:documentation>
          <xs:example>&lt;ultimapagina /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="operacaomatematica" type="operacaomatematica">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variaveldestino,operador,valor1,valor2</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>T;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Realiza uma operação matemática entre valor1 e valor2 e coloca seu resultado em variaveldestino.
            Os operadores matemáticos são:
            + : soma
            - : subtração
            * : multiplicação
            / : divisão
            ^ : exponenciação
            % : resto da divisão</xs:documentation>
            <xs:example>&lt;variavelstr valor="1.2" variavel="var1" /&gt;
&lt;variavelstr valor="3.4" variavel="var2" /&gt;
&lt;variavelstr valor=" " variavel="var3" /&gt;
&lt;operacaomatematica valor1="$(var1)" operador="+" valor2="$(var2)" variaveldestino="$(var3)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="somastring" type="somastring">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>valor1,valor2,variaveldestino</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>t;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Concatena duas strings, especificadas em valor1 e valor2, e após juntar os dois valores coloca o resultado na variável especificada em variaveldestino.</xs:documentation>
          <xs:example>&lt;variavelstr valor="AAA" variavel="var1" /&gt;
&lt;variavelstr valor="BBB" variavel="var2" /&gt;
&lt;variavelstr valor=" " variavel="var3" /&gt;
&lt;somastring valor1="$(var1)" valor2="$(var2)" variaveldestino="$(var3)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="excluiarquivo" type="excluiarquivo">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nomearquivo</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>x;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite excluir um arquivo do sistema de arquivos do pos.</xs:documentation>
					<xs:example>&lt;variavelstr valor="config.dat" variavel="filename" /&gt;
&lt;excluiarquivo nomearquivo="$(filename)" /&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="imprimacodigodebarras" type="imprimacodigodebarras">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>numero,horizontal</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>X;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Imprime o código de barras no formato I25, na horizontal ou vertical , especificado na variável string  numero. O formato I25 é o padrão adotado pela FEBRABAN ficando possível imprimir boletos de cobrança e qualquer outro titulo. O parâmetro numero deve ter o numero de caracteres par, pois é exigido pelo formato I25. Exemplo: "1234" funcionaria e imprimiria o código de barras normalmente. "123" não funcionaria, pois não conseguiríamos codificar no formato exigido pelo padrão I25.</xs:documentation>
					<xs:example>&lt;imprimacodigodebarras horizontal="0" numero="123456" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="esperateclatimeout" type="esperateclatimeout">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>segundos</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>U;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando esperateclatimeout é basicamente igual a instrução esperatecla . Aguarda o operador do terminal pressionar qualquer tecla no terminal para continuar alguma operação, com a diferença que podemos especificar em segundos o tempo que a instrução irá aguardar até que seja pressionado uma tecla para prosseguir a ação.</xs:documentation>
					<xs:example>&lt;esperateclatimeout segundos="10" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="execute" type="execute">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nomedoarquivo</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>j;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando execute permite executar um aplicativo PosXML compilado armazenado no disco. Basta passarmos o nome do arquivo no parametro nomedoarquivo para que se inicie a execução do mesmo.</xs:documentation>
					<xs:example>&lt;execute nomedoarquivo="inicio.posxml" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="while" type="while">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavel,operador,valor</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>V;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>v;false;false;false</xs:appinfo>
          <xs:documentation>A instrução while é um termo utilizado para especificar uma tomada de decisão ou comparação lógica dentro do programa POSXML. Outros comandos e instruções podem ser contidos dentro do argumento while e /while. Os comandos e instruções dentro do argumento são executados até que a expressão se torne falsa.
            A instrução processa a operação entre variavel e o valor especificado, e entra na execução da próxima instrução dentro de if, caso seja verdadeiro o resultado.
            Todos os operadores (igual/diferente/maior/menor/maiorigual/menorigual) no caso de variável inteiro realizam as operações padrões de comparação de qualquer linguagem de programação.
            Já os operadores (maior/menor/maiorigual/menorigual) no caso de variável string, converterá a variável para ponto flutuante e realizarão a comparação. Os operadores (igual/diferente) seguem a mesma lógica de comparação de qualquer linguagem de programação.</xs:documentation>
            <xs:example>&lt;variavelint valor="0" variavel="i" /&gt;
&lt;while variavel="$(i)" operador="menor" valor="10"&gt;
  &lt;display linha="0" coluna="0" mensagem=" Loop ..." /&gt;
  &lt;variavelintoperador operador="++" variavelorigem="$(i) /&gt;
&lt;/while&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="break" type="break">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>Z;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando break possibilita a saida imediata do loop while.</xs:documentation>
					<xs:example>&lt;variavelint valor="0" variavel="i" /&gt;
&lt;while variavel="$(i)" operador="menor" valor="10"&gt;
  &lt;display linha="0" coluna="0" mensagem=" Loop ..." /&gt;
  &lt;variavelintoperador operador="++" variavelorigem="$(i) /&gt;
  &lt;break /&gt;
&lt;/while&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="openserialport" type="openserialport">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>porta,velocidade,configuracao,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>Y;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Abre a porta serial para comunicacao com periféricos externos.</xs:documentation>
          <xs:example>&lt;variavelint valor="0" variavel="ret" /&gt;
&lt;openserialport porta="COM1" velocidade="115200" configuração="A8N1" variavelretorno="$(ret)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="readserialport" type="readserialport">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelhandle,variavelbuffer,bytes,timeout,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>w;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Lê um buffer capturado pela porta serial que está plugada a um dispositivo externo, previamente aberta com a instrução openserialport.</xs:documentation>
          <xs:example>&lt;variavelint valor="0" variavel="ret" /&gt;
&lt;variavelint valor="0" variavel="readBytes" /&gt;
&lt;variavelstr valor="" variavel="buf" /&gt;
&lt;openserialport porta="COM1" velocidade="115200" configuração="A8N1" variavelretorno="$(ret)" /&gt;
&lt;readserialport variavelhandle="$(ret)" variavelbuffer="$(buf)" bytes="10" timeout="2000" variavelretorno="$(readBytes)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="writeserialport" type="writeserialport">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelhandle,buffer</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>W;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Escreve um buffer na porta serial, previamente aberta com a instrução openserialport.</xs:documentation>
          <xs:example>&lt;variavelint valor="0" variavel="ret" /&gt;
&lt;variavelint valor="0" variavel="readBytes" /&gt;
&lt;variavelstr valor="" variavel="buf" /&gt;
&lt;openserialport porta="COM1" velocidade="115200" configuração="A8N1" variavelretorno="$(ret)" /&gt;
&lt;writeserialport variavelhandle="$(ret)" buffer="Hello World" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="closeserialport" type="closeserialport">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelhandle</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>!;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Fecha a porta serial serial, previamente aberta com a instrução openserialport.</xs:documentation>
					<xs:example>&lt;variavelint valor="0" variavel="iRet" /&gt;
&lt;openserialport porta="COM1" velocidade="115200" configuracao="A8N1" variavelretorno="$(iRet)" /&gt;
&lt;closeserialport variavelhandle="$(iRet)" /&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.length" type="string.length">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>valor,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>@;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Retorna o tamanho da string especificada</xs:documentation>
          <xs:example>&lt;variavelint valor="0" variavel="tamanho" /&gt;
&lt;string.length valor="Hello World" variavelretorno="$(tamanho)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="exit" type="exit">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>1;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Encerra imediatamente a execução do aplicativo PosXML.</xs:documentation>
					<xs:example>&lt;variavelint valor="0" variavel="i" /&gt;
&lt;while variavel="$(i)" operador="menor" valor="10"&gt;
  &lt;display linha="0" coluna="0" mensagem=" Loop ..." /&gt;
  &lt;variavelintoperador operador="++" variavelorigem="$(i) /&gt;
  &lt;exit /&gt;
&lt;/while&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="enviaarquivo" type="enviaarquivo">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nomearquivo,caminhoremoto,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>3;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Envia um arquivo do terminal para o WALK Server, em um protocolo de comunicação próprio semelhante ao FTP. Se no envio não ocorrer nenhum erro o arquivo vai estar disponivel no caminho remoto especificado, dentro da pasta de upload do WALK Server.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="baixaarquivo" type="baixaarquivo">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nomearquivo,caminhoremoto,excluiaposdownload,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>4;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Baixa um arquivo do WALK Server para o terminal, em um protocolo de comunicação próprio semelhante ao FTP. O terminal vai buscar o arquivo dentro da pasta de downloads do WALK Server.</xs:documentation>
					<xs:example>&lt;variavelint value="0" variable="iRet" /&gt;
&lt;baixaarquivo nomearquivo="file.dat" caminhoremoto="\file.dat" excluiaposdownload="0" variavelretorno="$(iRet)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="learquivobyindex" type="learquivobyindex">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nomearquivo,index,variavelchave,variavelvalor,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>%;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite ler um arquivo no formato WALK dbfile , ex: ‘chave="valor"\nchave="valor"\n’. Especificamos o index da chave que queremos pesquisas, e se a mesma existir no arquivo, variavelchave, e variavelvalor serão preenchidos com seus respectivos valores.
            Se por algum motivo o arquivo não existir, o nome da chave não existir no arquivo, ou qualquer outro erro no sistema de arquivos, variavelretorno será igual a 0. Do contrário será igual a 1.
            Pode-se ler arquivos criados por instruções PosXML ou mesmo arquivos criados em outros programas e carregados no terminal de alguma maneira, desde que sigam o formato citado.</xs:documentation>
					<xs:example>	&lt;variavelstr valor="" variavel="key" /&gt;
&lt;variavelstr valor="" variavel="value" /&gt;
&lt;variavelint valor="0" variavel="ret" /&gt;
&lt;learquivobyindex nomearquivo="teste.db" index="0" variavelchave="$(key)" variavelvalor="$(value)" variavelretorno="$(ret)" /&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="incrementadatahora" type="incrementadatahora">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>datahora,formatoretorno,dias,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>6;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite incrementar a data especificada em datahora, em dias. Em formatoretorno, qualquer caractere de formatação de data vai ser substituído pela data modificada. Os caracteres reservados para formatação de data são:
            yy: Ano com 4 dígitos
            y: Ano com 2 dígitos
            M: mês com 2 dígitos
            d: dia com 2 dígitos
            h: hora com 2 dígitos
            m: minuto com 2 dígitos
            s: segundos com 2 dígitos
          </xs:documentation>
					<xs:example>&lt;variavelstr valor="0" variavel="var"/&gt;
&lt;incrementadatahora datahora="20070501165807" dias="5" formatoretorno="d/M/y h:m:s" variavelretorno="$(var)"/&gt;
&lt;display coluna="0" linha="0" mensagem="$(var)"/&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="diferencadatahora" type="diferencadatahora">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>datahora1,datahora2,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>7;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite calcular a diferença entre as 2 datas especificadas em datahora1 e datahora2. O resultado será colocado em variavelretorno, no forma de segundos. Se a diferença entre as duas datas ultrapassar uma hora, a funcao indicará erro de datetime.</xs:documentation>
					<xs:example>&lt;variavelint valor="0" variavel="var"/&gt;
&lt;variavelstr valor="" variavel="var2"/&gt;
&lt;diferencadatahora datahora1="20070510155135" datahora2="20070510155030" variavelretorno="$(var)"/&gt;
&lt;inttostring variavelint="$(var)" variavelstr="$(var2)"/&gt;
&lt;display coluna="0" linha="0" mensagem="$(var2)"/&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="mostrabitmap" type="mostrabitmap">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nomearquivo,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>8;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite mostrar um bitmap monocromático no visor do terminal</xs:documentation>
					<xs:example>&lt;variavelint valor="1" variavel="ret"/&gt;
&lt;variavelstr valor="teste.bmp" variavel="arquivobmp"/&gt;
&lt;baixaarquivo caminhoremoto="\teste.bmp" excluiaposdownload="0" nomearquivo="$(arquivobmp)" variavelretorno="$(ret)"/&gt;
&lt;mostrabitmap nomearquivo="$(arquivobmp)" variavelretorno="$(ret)"/&gt;
&lt;esperatecla/&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="imprimabitmap" type="imprimabitmap">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nomearquivo,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>9;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite imprimir um bitmap monocromático</xs:documentation>
					<xs:example>&lt;variavelint valor="1" variavel="ret"/&gt;
&lt;variavelstr valor="teste.bmp" variavel="arquivobmp"/&gt;
&lt;baixaarquivo caminhoremoto="\teste.bmp" excluiaposdownload="0" nomearquivo="$(arquivobmp)" variavelretorno="$(ret)"/&gt;
&lt;imprimabitmap nomearquivo="$(arquivobmp)" variavelretorno="$(ret)"/&gt;
&lt;esperatecla/&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="letecla" type="letecla">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>milisegundos,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>/;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando letecla é basicamente igual a instrução esperateclatimeout . Aguarda o operador do terminal pressionar qualquer tecla no terminal para continuar alguma operação, com a diferença em variavelretorno temos a tecla pressionada pelo operador.</xs:documentation>
					<xs:example>&lt;variavelint valor="2000" variavel="segs"/&gt;
&lt;variavelstr valor="" variavel="ret"/&gt;
&lt;variavelstr valor="KEY_1" variavel="tecla"/&gt;
&lt;display coluna="0" linha="0" mensagem="aperte uma tecla"/&gt;
&lt;letecla milisegundos="$(segs)" variavelretorno="$(ret)"/&gt;

&lt;if operador="igual" variavel="$(ret)" valor="$(tecla)"&gt;
  &lt;display coluna="0" linha="1" mensagem="numero 1 digitado!"/&gt;
  &lt;esperatecla/&gt;
&lt;/if&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="unzipfile" type="unzipfile">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nomearquivo,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite descompactar um arquivo compactado no formato zip. Os arquivos dentro do .zip serão extraido para o mesmo diretório onde se encontra o arquivo zipado especificado.</xs:documentation>
          <xs:example>&lt;ariavelint valor="0" variavel="ret"/&gt;
&lt;ariavelstr valor="teste.zip" variavel="nomearq"/&gt;
&lt;baixaarquivo caminhoremoto="\teste.zip" excluiaposdownload="0" nomearquivo="$(nomearq)" variavelretorno="$(ret)"/&gt;
&lt;nzipfile nomearquivo="$(nomearq)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="else" type="else">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>,;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando else é utilizado dentro de um if, como uma condição lógica.</xs:documentation>
					<xs:example>&lt;variavelint valor="0" variavel="num"/&gt;
&lt;if operador="igual" variavel="$(num)" valor="1"&gt;
  &lt;display coluna="0" linha="0" mensagem="Variavel igual a 1"/&gt;
  &lt;esperatecla/&gt;
&lt;else/&gt;
  &lt;display coluna="0" linha="0" mensagem="Variavel diferente de 1"/&gt;
  &lt;esperatecla/&gt;
&lt;/if&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="conversaointeiro" type="conversaointeiro">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>numero,base,tamanhoretorno,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x01;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite converter um número inteiro em um número binário, octal ou hexadecimal.</xs:documentation>
					<xs:example>&lt;variavelint valor="12" variavel="iNum"/&gt;
&lt;variavelint valor="2" variavel="iBase"/&gt;
&lt;variavelint valor="10" variavel="iTamanho"/&gt;
&lt;variavelstr valor="" variavel="sRet"/&gt;
&lt;conversaointeiro numero="$(iNum)" base="$(iBase)" tamanhoretorno="$(iTamanho)" variavelretorno="$(sRet)"/&gt;
&lt;display coluna="0" linha="0" mensagem="$(sRet)"/&gt;
&lt;esperatecla/&gt;
					</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="iso8583.iniciatabelacampos" type="iso8583.iniciatabelacampos">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nomearquivo,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x02;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Inicia a tabela de campos ISO8583 de acordo com os campos especificados no arquivo definido no parâmetro nomearquivo. Esta função deve ser chamada antes de iniciarmos o trabalho com as mensagens ISO8583.</xs:documentation>
					<xs:example>&lt;iso8583.iniciatabelacampos nomearquivo="$(arquivo)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="iso8583.iniciamensagem" type="iso8583.iniciamensagem">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>formato,identificador,variavelmensagem,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x03;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Inicia a montagem de uma mensagem que será enviada ao host autorizador.</xs:documentation>
					<xs:example>&lt;iso8583.iniciamensagem formato="$(formato)" identificador="$(id)" variavelmensagem="$(var_msg)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="iso8583.analisamensagem" type="iso8583.analisamensagem">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>formato,tamanho,variavelmensagem,variavelidentificador,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x05;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Inicia o processo de análise e decomposição dos campos da mensagem especificada.</xs:documentation>
					<xs:example>&lt;iso8583.analisamensagem formato="$(formato)" tamanho="$(tam)" variavelmensagem="$(var_msg)" variavelidentificador="$(var_id)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="iso8583.finalizamensagem" type="iso8583.finalizamensagem">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variaveltamanho,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x06;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Finaliza a montagem de uma mensagem a ser enviada ao host autorizador,iniciada por iso8583.iniciamensagem.</xs:documentation>
					<xs:example>&lt;iso8583.finalizamensagem variaveltamanho="$(tam)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="iso8583.inserecampo" type="iso8583.inserecampo">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>numerocampo,tipo,valor,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x07;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Insere um campo na mensagem a ser enviada, iniciada por iso8583.iniciamensagem. Os campos devem ser inseridos sempre em ordem crescente.</xs:documentation>
					<xs:example>&lt;iso8583.inserecampo numerocampo="$(n_campo)" tipo="$(tipo)" valor="$(val)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="iso8583.pegacampo" type="iso8583.pegacampo">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>numerocampo,tipo,variavelvalor,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x08;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Extrai um campo de uma mensagem previamente analisada através de iso8583.analisamensagem. Os campos devem ser extraídos sempre em ordem crescente.</xs:documentation>
					<xs:example>&lt;iso8583.pegacampo numerocampo="$(n_campo)" tipo="$(tipo)" variavelvalor="$(val)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.charat" type="string.charat">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>string,character_index,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x09;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Extrai um character da string especificada.</xs:documentation>
          <xs:example>&lt;string.charat string="$(str)" character_index="$(index)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.trim" type="string.trim">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>string,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x0B;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Elimina os espaços em branco da esquerda e da direita da string especificada.</xs:documentation>
          <xs:example>&lt;string.trim string="$(str)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.find" type="string.find">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>string,substring,start,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x0C;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Procura por uma substring na string especificada.</xs:documentation>
          <xs:example>&lt;string.find string="$(str)" substring="$(sub_str)" start="$(index)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.replace" type="string.replace">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>original_string,old_substring,new_substring,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x0E;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Substitui todas as ocorrencias da substring especificada na string original.</xs:documentation>
          <xs:example>&lt;string.replace original_string="$(str_orig)" old_substring="$(str_val)" new_substring="$(str_new)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.substring" type="string.substring">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>string,start,length,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x0F;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite pegar um pedaço da string especificada.</xs:documentation>
          <xs:example>&lt;string.substring string="$(str)" start="$(index)" length="$(tamanho)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.elements" type="string.elements">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>string,delimiter,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x10;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Retorna quantos elementos existem na string especificada separados pelo character delimiter. Mesmo quanto o character especificado em delimiter não existe na string teremos 1 elemento.</xs:documentation>
          <xs:example>&lt;string.elements string="$(str)" delimiter="$(dlmt)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.insertat" type="string.insertat">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>string,string_to_be_inserted,element_index,delimiter,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x11;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite inserir um elemento em um index especifico na string especificada separada pelo character delimiter.</xs:documentation>
          <xs:example>&lt;string.insertat string="$(str)" string_to_be_inserted="$(str_insert)" element_index="$(index)" delimiter="$(dlmt)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.replaceat" type="string.replaceat">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>string,new_element,element_index,delimiter,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x12;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite substituir um elemento em um index especifico na string especificada separada pelo character delimiter.</xs:documentation>
          <xs:example>&lt;string.replaceat string="$(str)" new_element="$(new_elemt)" element_index="$(index)" delimiter="$(dlmt)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.elementat" type="string.elementat">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>string,element_index,delimiter,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x13;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Retorna um elemento em um index especifico na string especificada separada pelo character delimiter.</xs:documentation>
          <xs:example>&lt;string.elementat string="$(str)" element_index="$(index)" delimiter="$(dlmt)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.removeat" type="string.removeat">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>string,element_index,delimiter,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x14;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Remove um elemento em um index especifico na string especificada separada pelo character delimiter.</xs:documentation>
          <xs:example>&lt;string.removeat string="$(str)" element_index="$(index)" delimiter="$(dlmt)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="network.send" type="network.send">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>buffer,tamanho,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x15;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Envia um buffer para o host que atualmente estamos conectados. É necessário já estar conectado a um host com a instrução pré-conectar.</xs:documentation>
          <xs:example>&lt;network.send buffer="$(buf)" tamanho="$(tamanho)" variaveretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="network.receive" type="network.receive">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelbuffer,tamanhomaximo,variavelbytesrecebidos,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x16;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Recebe um buffer do host que atualmente estamos conectados. É necessário já estar conectado a um host com a instrução pré-conectar.</xs:documentation>
          <xs:example>&lt;network.receive variavelbuffer="$(buf)" tamanhomaximo="$(tamanho_max)" variavelbytesrecebidos="$(bytes)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="system.reinicia" type="system.reinicia">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x17;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Reinicia o terminal.</xs:documentation>
          <xs:example>&lt;system.reinicia/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="network.httprequest" type="network.httprequest">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>url,campos,savetofile,variavelresponse,variavelstatuscode,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x18;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite realizar um 'POST' ou 'GET' do protocolo HTTP. Possibilita baixar e enviar arquivos, receber e enviar informacoes de um servidor HTTP.</xs:documentation>
          <xs:example>&lt;network.httprequest url="$(str_url)" campos="$(str_campos)" savetofile="$(str_file)" variavelresponse="$(str_response)" variavelstatuscode="$(str_status)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="filesystem.filesize" type="filesystem.filesize">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>nomearquivo,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x19;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Retorna o tamanho do arquivo especificado</xs:documentation>
					<xs:example>&lt;filesystem.filesize nomearquivo="$(nome)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="filesystem.space" type="filesystem.space">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>dir,tipo,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x1A;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite verificar o tamanho total da memória, o espaço utilizado, o espaço livre e o número de arquivos na memória</xs:documentation>
					<xs:example>&lt;filesystem.space dir="$(dir)" tipo="$(tipo)" variavelretorno="$(ret)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="filesystem.listfiles" type="filesystem.listfiles">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>dir,nomearquivolista,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x1B;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Lista os arquivos do diretório especificado e salva em um arquivo no formato 'Walk Db File'</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="convert.toint" type="convert.toint">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>base,numero,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x1D;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite converter uma string contendo um número binário, decimal ou hexadecimal em um número inteiro.</xs:documentation>
					<xs:example>&lt;convert.toint base="16" numero="FF" variavelretorno="$(num)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="predial" type="predial">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>opcao,variavelstatus</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>#;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando predial inicializa o dispositivo de discagem e retorna na variável especificada se conseguiu discar. Se a variável for igual a -2, o comando passado em opcao é diferente de 1 ou 2. Se a variável for igual a -1 , ocorreu algum erro na discagem. Se a variável for igual a 0 o terminal conseguiu discar. Lembrando que está instrução não envia nenhuma informação ou se conecta ao host, apenas faz a discagem. Para conectar e enviar as variáveis coletadas devemos chamar a instrução conectar.</xs:documentation>
          <xs:example>&lt;predial opcao="1" variavelstatus="$(status)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="network.checkgprssignal" type="network.checkgprssignal">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelstatus</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>$;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando network.checkgprssignal checa o status da conexão. Caso o terminal tenha suporte a conexão GPRS.</xs:documentation>
					<xs:example>&lt;network.checkgprssignal variavelstatus="$(status)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="system.checkbattery" type="system.checkbattery">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelstatus</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>';false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando system.checkbattery checa o status da bateria do terminal. Caso o terminal possua bateria.</xs:documentation>
          <xs:example>&lt;system.checkbattery variavelstatus="$(status)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="network.ping" type="network.ping">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>O;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando network_ping checa o status do host.</xs:documentation>
          <xs:example>&lt;network.ping variavelretorno="$(retorno)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="system.beep" type="system.beep">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>Q;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando system.beep executa um sinal sonoro curto.</xs:documentation>
          <xs:example>&lt;system.beep /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="system.readcard" type="system.readcard">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variaveltecla,variavelcartao,timeout,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x26;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Essa função espera que um cartão seja passado ou uma tecla seja pressionada, o tempo esperado é especificado em timeout. Caso nenhuma ação seja tomada, os valores de retorno padrão são: variaveltecla="KEY_CANCEL", variavelcartao="0". É possível também usar esta instrução com um cartão EMV, caso o cartão passado seja um cartão com chip a instrução 'emv.inittransaction' será executada.</xs:documentation>
          <xs:example>&lt;system.readcard variaveltecla="$(tecla)" variavelcartao="$(cartao)" timeout="5000" variavelretorno="$(ret)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="system.inputtransaction" type="system.inputtransaction">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variaveltecla,variavelcartao,timeout,variavelretorno,mkslot,pinpadtype,pinpadwk,showamount,inputtype</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x91;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Essa função espera que um cartão seja passado ou uma tecla seja pressionada, o tempo esperado é especificado em timeout. Caso nenhuma ação seja tomada, os valores de retorno padrão são: variaveltecla="KEY_CANCEL", variavelcartao="0". É possível também usar esta instrução com um cartão EMV, caso o cartão passado seja um cartão com chip a instrução 'emv.inittransaction' será executada.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="network.hostdisconnect" type="network.hostdisconnect">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x65;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando network.hostdisconnect desconecta o terminal do host, mas mantém o terminal conectado a rede.</xs:documentation>
					<xs:example>&lt;network.hostdisconnect /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="iso8583.transactmessage" type="iso8583.transactmessage">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>channel,header,trailler,isomsg,variavelresposta,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x3B;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Conecta ao host, acrescenta size, header e trailer na mensagem iso de acordo com os parametros especificados, envia ao host e faz 10 tentativas de recebimento da mensagem de resposta.</xs:documentation>
					<xs:example>&lt;iso8583.transactmessage channel="NONE" header="$(header)" trailler="$(trailler)" isomsg="$(isomsg)" variavelresposta="$(resposta)" variavelretorno="$(retorno)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="smartcard.cartaoinserido" type="smartcard.cartaoinserido">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>slot,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>|;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Verifica se o cartão está inserido no leitor de smart card do terminal Pos.</xs:documentation>
          <xs:example>&lt;variavelint valor="0" variavel="ret" /&gt;
&lt;smartcard.cartaoinserido slot="1" variavelretorno="$(ret)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="smartcard.inicialeitor" type="smartcard.inicialeitor">
        <xs:annotation>
        <!-- ordem dos parametros -->
        <xs:appinfo>slot,variavelretorno</xs:appinfo>
        <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
        <xs:appinfo>=;true;false;false</xs:appinfo>
        <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
        <xs:appinfo>
        </xs:appinfo>
        <xs:documentation>Inicia o leitor de smart card do terminal e tenta iniciar o cartão no slot informado, verificando o ATR do cartão.</xs:documentation>
        <xs:example>&lt;variavelint valor="0" variavel="ret" /&gt;
&lt;smartcard.inicialeitor slot="1" variavelretorno="$(ret)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="smartcard.transmitAPDU" type="smartcard.transmitAPDU">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>slot,header,LC,datafield,LE,variaveldatafieldresponse,variavelSW,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>.;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Envia um comand APDU para o smart card inserido no slot especificado. Antes de utilizarmos esta instrução já devemos ter iniciado o cartão com um comando ATR feito pela instrução smartcard.inicialeitor. Em todos os parâmetros devemos passar variáveis strings no formato hexadecimal (utilize string.tohex e string.fromhex).</xs:documentation>
          <xs:example>&lt;smartcard.transmitAPDU slot="1" header="00B40300" LC="00" datafield="00" LE="00" variaveldatafieldresponse="$(sDatafield)" variavelSW="$(sSW)" variavelretorno="$(iRet)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="smartcard.fechaleitor" type="smartcard.fechaleitor">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>slot,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>2;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Finalizar o processo de comunicação com o cartão , e fecha o leitor de smart card do terminal Pos.</xs:documentation>
          <xs:example>&lt;variavelint valor="0" variavel="ret" /&gt;
&lt;smartcard.fechaleitor slot="1" variavelretorno="$(ret)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.tohex" type="string.tohex">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>string,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>0;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Converte uma string para sua representação em hexadecimal. Exemplo: '12345' será igual '3132333435'</xs:documentation>
          <xs:example>&lt;string.tohex string="12345" variavelretorno="$(str_hex)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="string.fromhex" type="string.fromhex">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>string,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>?;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Converte uma representação em hexadecimal para uma string. Exemplo: '3132333435' será igual '12345'</xs:documentation>
          <xs:example>&lt;string.fromhex string="3132333435" variavelretorno="$(str_ascii)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="crypto.encryptdecrypt" type="crypto.encryptdecrypt">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>message,key,cryptotype,type,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>{;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Criptografa ou descriptografa uma mensagem utilizando DES,3DES ou NEWDES.</xs:documentation>
					<xs:example>&lt;crypto.encryptdecrypt cryptotype="3DES" key="30313233" message="$(str_msg)" type="0" variablereturn="$(str_msg_cript)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="crypto.lrc" type="crypto.lrc">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>buffer,size,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>};true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Gera um byte de LRC da string em buffer.</xs:documentation>
					<xs:example>&lt;crypto.lrc buffer="4B91443C5F1234" size="7" variavelretorno="$(sHexLrc)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="crypto.xor" type="crypto.xor">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>buffer1,buffer2,size,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>^;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Realiza uma operacao binaria XOR entre os bytes de buffer1 e buffer2.</xs:documentation>
					<xs:example>&lt;crypto.xor buffer1="$(hexStartVector)" buffer2="$(sPacket8Bytes)" size="8" variavelretorno="$(hexPacket8BytesXOR)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="crypto.crc" type="crypto.crc">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>buffer,tamanho,tipocrc,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>_;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Calculo CRC 16 bits, suporte a CRC-CCITT.</xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="system.info" type="system.info">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>tipo,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>`;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Busca de informações no sistema, como MAC Address e SIM ID.</xs:documentation>
          <xs:example>&lt;editaarquivo nomearquivo="config.dat" chave="uclmedia" valor="ETHERNET"/&gt;
&lt;editaarquivo nomearquivo="config.dat" chave="uclprotocol" valor="TCP"/&gt;
&lt;editaarquivo nomearquivo="config.dat" chave="myip" valor="192.168.0.202"/&gt;
&lt;editaarquivo nomearquivo="config.dat" chave="mygateway" valor="192.168.0.1"/&gt;
&lt;editaarquivo nomearquivo="config.dat" chave="dnsprimario" valor="8.8.8.8"/&gt;
&lt;editaarquivo nomearquivo="config.dat" chave="iphost" valor="192.168.0.177"/&gt;
&lt;editaarquivo nomearquivo="config.dat" chave="portahost" valor="8000"/&gt;
&lt;editaarquivo nomearquivo="config.dat" chave="withssl" valor="0"/&gt;
 
&lt;variavelstr valor="" variavel="sRet"/&gt;
&lt;system.info tipo="macaddress" variavelretorno="$(sRet)"/&gt;
 
&lt;display coluna="0" linha="0" mensagem="$(sRet)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="system.gettouchscreen" type="system.gettouchscreen">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>eixox,eixoy,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x87;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando system.gettouchscreen captura as coordenadas onde o display foi pressionado. </xs:documentation>
        </xs:annotation>
      </xs:element>
      <xs:element name="pinpad.open" type="pinpad.open">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>type,variavelserialnumber,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x1C;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando pinpad.open habilita a comunicacao entre o pinpad externo ou interno e o terminal POS.</xs:documentation>
          <xs:example>&lt;pinpad.open type="1" variavelserialnumber="$(sSerial)" variavelretorno="$(iRet)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="pinpad.display" type="pinpad.display">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>message</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>(;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando pinpad.display exibe a mensagem contida no parâmetro message no display do pinpad externo. Não aplica ao pinpad interno.</xs:documentation>
          <xs:example>&lt;pinpad.display message="$(sMessage)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="pinpad.getkey" type="pinpad.getkey">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>message,timeout,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>);true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando pinpad.getkey captura uma tecla que seja pressionada no pinpad externo enquanto exibe uma mensagem contida no parametro message no display do pinpad externo. Não aplica ao pinpad interno.</xs:documentation>
          <xs:example>&lt;pinpad.getkey message="$(sMessage)" timeout="10" variavelretorno="$(iRet)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="pinpad.getpindukpt" type="pinpad.getpindukpt">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>message,type,pan,maxlen,variavelretornopin,variavelretornoksn,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>*;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando pinpad.getpindukpt captura um pin e encripta o mesmo usando o padrao DUKPT no pinpad externo ou interno enquanto exibe uma mensagem contida no parametro message no display do pinpad externo ou na tela do terminal POS.</xs:documentation>
          <xs:example>&lt;pinpad.getpindukpt maxlen="$(iMax)" message="$(sMessage)" pan="$(sSen)" type="0" variavelretornoksn="$(sKsn)"
variavelretornopin="$(sPin)" variavelretorno="$(iRet)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="pinpad.loadipek" type="pinpad.loadipek">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>ipek,ksn,type,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>+;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando pinpad.loadipek grava uma chave inicial e uma ksn inicial na memória do pinpad interno ou externo para efetuarmos uma encriptação de senhas usando o pegadatahorapadrao DUKPT. </xs:documentation>
          <xs:example>&lt;pinpad.loadipek ipek="$(sIpek)" ksn="$(sKsn)" type="1" variavelretorno="$(iRet)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="pinpad.close" type="pinpad.close">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>message</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>~;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>O comando pinpad.close encerra a comunicacao com um pinpad externo ou interno que foi previamente estabelecida com pinpad.open. Ainda define a mensagem padrão do display do pinpad externo. </xs:documentation>
          <xs:example>&lt;pinpad.close message="Pinpad encerrado"/&gt;pegadatahora</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="emv.open" type="emv.open">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x2D;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Inicializa biblioteca EMV.</xs:documentation>
					<xs:example>&lt;emv.open variavelretorno="$(status)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="emv.settimeout" type="emv.settimeout">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>segundos,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x1E;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Define Timeout(em segundos) de biblioteca processos EMV.</xs:documentation>
					<xs:example>&lt;emv.settimeout segundos="30" variavelretorno="$(status)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="emv.loadtables" type="emv.loadtables">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>adquirente,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x5D;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Carrega tabelas EMV e PKI de arquivo por Adquirente.</xs:documentation>
					<xs:example>&lt;emv.loadtables adquirente="4" variavelretorno="$(status)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="emv.cleanstructures" type="emv.cleanstructures">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>
          </xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x1F;false;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Limpa todos os parametros de entrada e saída para 'init', 'process' e 'finish'.</xs:documentation>
					<xs:example>&lt;emv.cleanstructures/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="emv.adddata" type="emv.adddata">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>tipo,parametro,valor,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x88;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Adiciona parâmetros ao Processo EMV, tipos 'init', 'process', 'finish'.</xs:documentation>
					<xs:example>&lt;emv.adddata tipo="init" parametro="baInitialValue" valor="000000001000" variavelretorno="$(status)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="emv.getinfo" type="emv.getinfo">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>tipo,parametro,valor</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x35;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Retorna parâmetros de informação após execução de processo EMV, tipos 'init', 'process', 'finish'.</xs:documentation>
					<xs:example>&lt;emv.getinfo tipo="finish" parametro="bDecision" valor="$(sStatus)/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="emv.inittransaction" type="emv.inittransaction">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x20;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Inicializa EMV com os parâmetros inseridos em emv.adddata com tipo init .</xs:documentation>
					<xs:example>&lt;emv.inittransaction variavelretorno="$(status)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="emv.processtransaction" type="emv.processtransaction">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelretorno,mkslot,pinpadtype,pinpadwk,showamount,ctls</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x3A;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Processamento de transação EMV, utiliza dados inseridos emv.adddata com type process.</xs:documentation>
					<xs:example>&lt;emv.processtransaction variavelretorno="$(status)" mkslot=" " pinpadtype="1" pinpadwk=" " showamount="1"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="emv.finishtransaction" type="emv.finishtransaction">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x5B;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Finalização de transação EMV, utiliza dados inseridos emv.adddata com type finish</xs:documentation>
					<xs:example>&lt;emv.finishtransaction variavelretorno="$(sStatus)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="emv.removecard" type="emv.removecard">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x71;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Aguarda remoção do cartão, utiliza de emv.settimeout, se setado.</xs:documentation>
					<xs:example>&lt;emv.removecard variavelretorno="$(iStatus)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="parseticket" type="parseticket">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>produtomenu,ticket,mensagem,literais,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x80;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Aguarda remoção do cartão, utiliza de emv.settimeout, se setado.</xs:documentation>
          <xs:example>&lt;parseticket literais="$(sLiterais)" mensagem="sMensagem" produtomenu="$(sProduto)" ticket="$(sTicket)" variavelretorno="$(sParse)" /&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="file.open" type="file.open">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>mode,filename,variablehandle</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x83;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Abre um arquivo para leitura ou escrita.</xs:documentation>
					<xs:example>&lt;file.open filename="teste.dat" mode="w" variablehandle="$(iRet)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="file.close" type="file.close">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>handle</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x84;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Fecha um arquivo que foi previamente aberto com file.open.</xs:documentation>
					<xs:example>&lt;file.close handle="$(iRet)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="file.read" type="file.read">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>handle,size,variablebuffer,variablereturn</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x85;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Le um arquivo que foi previamente aberto com file.open.</xs:documentation>
					<xs:example>&lt;file.read handle="$(iRet)" size="8" variablebuffer="$(sBuffer)" variablereturn="$(iBufReturn)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="file.write" type="file.write">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>handle,size,buffer</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x86;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Grava um arquivo que foi previamente aberto com file.open.</xs:documentation>
					<xs:example>&lt;file.write buffer="$(sBuffer)" handle="$(iRet)" size="8"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
      <xs:element name="input.getvalue" type="input.getvalue">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>linecaption,columncaption,caption,lineinput,columninput,minimo,maximo,allowsempty,variablereturn</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x82;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Permite capturar uma string e mostra-la na tela em qualquer posição.</xs:documentation>
					<xs:example>&lt;input.getvalue caption="String:" columncaption="$(iColumncaption)" columinput="$(iColumninput)" linecaption="$(iLinecaption)" lineinput="$(iLineinput)" maximo="10" minimo="10" variablereturn="$(sReturn)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
	    <xs:element name="string.pad" type="string.pad">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>origem,caracter,align,length,destino</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x89;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>A string que é passada recebe um pad com o caractere especificado.</xs:documentation>
          <xs:example>&lt;string.pad align="left" caracter="#" destino="$(sStringwithpad)" length="$(iString)" origem="$(sString)"/&gt;</xs:example>
        </xs:annotation>
      </xs:element>
	    <xs:element name="time.calculate" type="time.calculate">
        <xs:annotation>
          <!-- ordem dos parametros -->
          <xs:appinfo>operacao,tipo,data,datamaior,valor,variavelretorno</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (startelement) -->
          <xs:appinfo>\x90;true;false;false</xs:appinfo>
          <!-- bytecode;tem parametros;declaracao ou chamada de funcao;declaracao de variavel; (endelement) -->
          <xs:appinfo>
          </xs:appinfo>
          <xs:documentation>Calculo de tempo, adição, subtração e diferença.</xs:documentation>
        </xs:annotation>
      </xs:element>
    </xs:choice>
  </xs:group>
  <xs:complexType name="display">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="linha" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Linha que vai ser exibida a mensagem. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="coluna" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Coluna que vai ser exibida a mensagem. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem que vai ser exibida no display. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="limpadisplay">
    <xs:sequence />
  </xs:complexType>
  <xs:complexType name="funcao">
    <xs:choice maxOccurs="unbounded">
      <xs:group ref="comandos" />
    </xs:choice>
    <xs:attribute name="nome" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Função a ser chamada. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="if">
    <xs:choice maxOccurs="unbounded">
      <xs:group ref="comandos" />
    </xs:choice>
    <xs:attribute name="variavel" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável para comparação. (string ou inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="operador" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Operador de comparação, que pode ser : menor,maior,igual,diferente,maiorigual,menorigual. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valor" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor para comparação. (string ou inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="digitainteiro">
    <xs:sequence />
    <xs:attribute name="variavel" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde ficará armazenado o valor digitado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linha" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Linha que vai ser exibida a mensagem. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="coluna" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Coluna que vai ser exibida a mensagem. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem que vai ser exibida no display. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minimo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número minimo a ser digitado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maximo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número máximo a ser digitado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="digitaopcao">
    <xs:sequence />
    <xs:attribute name="variavel" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde ficará armazenado o valor digitado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linha" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Linha que vai ser exibida a mensagem. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="coluna" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Coluna que vai ser exibida a mensagem. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem que vai ser exibida no display. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minimo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número minimo a ser digitado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maximo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número máximo a ser digitado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="digitavalor">
    <xs:sequence />
    <xs:attribute name="variavel" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde ficará armazenado o valor digitado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linha" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Linha que vai ser exibida a mensagem. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="coluna" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Coluna que vai ser exibida a mensagem. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem que vai ser exibida no display. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="digitaformato">
    <xs:sequence />
    <xs:attribute name="variavel" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde ficará armazenado o valor digitado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linha" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Linha que vai ser exibida a mensagem. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="coluna" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Coluna que vai ser exibida a mensagem. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem que vai ser exibida no display. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="formato" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Máscara para digitação dos dados: 9 : número * : senha A : letra. Os demais caracteres serão inseridos automaticamente. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="imprima">
    <xs:sequence />
    <xs:attribute name="mensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem a ser impressa pela impressora do terminal. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="imprimagrande">
    <xs:sequence />
    <xs:attribute name="mensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem a ser impressa pela impressora do terminal. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="paperfeed">
    <xs:sequence />
  </xs:complexType>
  <xs:complexType name="digitadecimal">
    <xs:sequence />
    <xs:attribute name="variavel" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde ficará armazenado o valor digitado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="linha" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Linha que vai ser exibida a mensagem. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="coluna" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Coluna que vai ser exibida a mensagem. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem que vai ser exibida no display. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="conectar">
    <xs:sequence />
  </xs:complexType>
  <xs:complexType name="preconexao">
    <xs:sequence />
    <xs:attribute name="variavelstatus" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável que indica o status da conexão. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="desligamodem">
    <xs:sequence />
  </xs:complexType>
  <xs:complexType name="pegacartao">
    <xs:sequence />
    <xs:attribute name="primeiramensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Primeira mensagem que vai ser exibida no display. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="segundamensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Segunda mensagem que vai ser exibida no display, após o usuário pressionar OK. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minimo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número minimo de caracteres a serem digitados. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maximo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número máximo de caracteres a serem digitados. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="pegacartaoevariavel">
    <xs:sequence />
    <xs:attribute name="primeiramensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Primeira mensagem que vai ser exibida no display. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="segundamensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Segunda mensagem que vai ser exibida no display, após o usuário pressionar OK. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minimo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número minimo de caracteres a serem digitados. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maximo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número máximo de caracteres a serem digitados. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavel" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde ficará armazenado o valor do cartão. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="imprimalogo">
    <xs:sequence />
    <xs:attribute name="index" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Indica o número do logo a ser impresso pelo terminal. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="esperatecla">
    <xs:sequence />
  </xs:complexType>
  <xs:complexType name="espera">
    <xs:sequence />
    <xs:attribute type="xs:string" use="required" name="milisegundos">
      <xs:annotation>
        <xs:documentation>Milisegundos que a instrução vai aguardar antes de continuar a execução. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="guardavariavel">
    <xs:sequence />
    <xs:attribute name="variavel" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Váriavel que vai ser armazenada no buffer que será enviado ao terminal. (string ou inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="limpavariaveis">
    <xs:sequence />
  </xs:complexType>
  <xs:complexType name="chamafuncao">
    <xs:sequence />
    <xs:attribute name="nome" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Função a ser chamada para execução. (função)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="variavelint">
    <xs:sequence />
    <xs:attribute name="valor" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor da variável. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavel" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome da variável. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="variavelstr">
    <xs:sequence />
    <xs:attribute name="valor" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor da variável. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavel" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome da variável. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="substring">
    <xs:sequence />
    <xs:attribute name="posicao" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Indica a partir de que posicao vamos copiar a string até encontrar o caracter especificado. A primeira posicao é 0. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelorigem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde vai ser feito o substring. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variaveldestino" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde vai ficar armazenado o resultado do substring. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="caracter" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Caractere delimitador. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Posição do caracter , se este foi encontrado. Se não foi encontrado o caracter retorna -1. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="stringtoint">
    <xs:sequence />
    <xs:attribute name="variavelstr" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável que vai ser convertida. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelint" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável que vai armazenar o valor inteiro. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="inttostring">
    <xs:sequence />
    <xs:attribute name="variavelint" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável que vai ser convertida. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelstr" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável que vai armazenar o valor string. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.getvaluebykey">
    <xs:sequence />
    <xs:attribute name="string" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String em que vamos pesquisar. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chave" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Chave do valor que queremos ler da string. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde ficará armazenado o valor vindo da string. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="menu">
    <xs:sequence />
    <xs:attribute name="variavel" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde ficará armazenado o valor digitado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="opcoes" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Opções do menu delimitadas por '\'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="menuwithheader">
    <xs:sequence />
    <xs:attribute name="header" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Opções do cabeçalho delimitadas por '|'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="options" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Opções do menu delimitadas por '\'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeoutheader" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tempo para troca do próximo cabeçalho. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Timeout de função, iskeytimeout deve ser 1. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variablereturn" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde ficará armazenado o valor digitado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="learquivo">
    <xs:sequence />
    <xs:attribute name="nomearquivo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo em disco a ser aberto. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chave" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Chave do valor, que queremos ler do arquivo. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variaveldestino" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde ficará armazenado o valor lido. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="editaarquivo">
    <xs:sequence />
    <xs:attribute name="nomearquivo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo a ser editado ou criado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="chave" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Chave do valor, que queremos editar no arquivo. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valor" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor que será atribuido a chave especificado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="variavelintoperador">
    <xs:sequence />
    <xs:attribute name="operador" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Operador de incremento '++' ou decremento '--'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelorigem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável que vai ser incrementada ou decrementada. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ajustadatahora">
    <xs:sequence />
    <xs:attribute name="datahora" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Data/hora no formato yyyyMMddhhmmss. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="pegadatahora">
    <xs:sequence />
    <xs:attribute name="formato" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Formato da data que vai ser armazenada. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variaveldestino" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável contendo a data no formato especificado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="verificapapelimpressora">
    <xs:sequence />
    <xs:attribute name="variavelresultado" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável contendo o resultado da verificação do papel. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="ultimapagina">
    <xs:sequence />
  </xs:complexType>
  <xs:complexType name="operacaomatematica">
    <xs:sequence />
    <xs:attribute name="valor1" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Primeiro valor da operação matemática. (string ou inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="operador" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Operador da operação matemática, sendo : +,-,*,/,%,^. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valor2" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Segunda valor da operação matemática. (string ou inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variaveldestino" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável contendo o resultado da operação matemática. (string ou inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="somastring">
    <xs:sequence />
    <xs:attribute name="valor1" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor a ser concatenado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valor2" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor a ser concatenado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variaveldestino" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável contendo o resultado da concatenação. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="excluiarquivo">
    <xs:sequence />
    <xs:attribute name="nomearquivo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo a ser excluído. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="imprimacodigodebarras">
    <xs:sequence />
    <xs:attribute name="numero" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número do código de barras a ser impresso. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="horizontal" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Coloque o valor 1 se você deseja que o código de barras seja impresso na horizontal. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="esperateclatimeout">
    <xs:sequence />
    <xs:attribute name="segundos" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Segundos que a instrução vai aguardar antes de continuar a execução. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="execute">
    <xs:sequence />
    <xs:attribute name="nomedoarquivo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo PosXML compilado que será executado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="while">
    <xs:choice maxOccurs="unbounded">
      <xs:group ref="comandos" />
    </xs:choice>
    <xs:attribute name="variavel" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável para comparação. (string ou inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="operador" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Operador de comparação, que pode ser : menor,maior,igual,diferente,maiorigual,menorigual. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valor" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor para comparação. (string ou inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="break">
    <xs:sequence />
  </xs:complexType>
  <xs:complexType name="openserialport">
    <xs:sequence />
    <xs:attribute name="porta" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome da porta serial. Pode ser: COM1,COM2,COM3,COM4,COM5,COM6. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="velocidade" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Velocidade da porta serial. Pode ser: 300,600,1200,2400,4800,9600,19200,38400,57600,115200,12000,14400,28800,33600. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="configuracao" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Configuracao da porta serial. Pode ser: A7E1,A7N1,A7O1,A8E1,A8N1,A8O1. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Retorna -2 , se algum parametro de configuração está incorreto. Qualquer valor menor ou igual a zero, ocorreu algum erro no processo de abertura da porta serial. Se abriu com sucesso retorna a handle para manipular a porta serial através das instruções:readserialport,writeserialport e closeserialport. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="readserialport">
    <xs:sequence />
    <xs:attribute name="variavelhandle" type="xs:string">
      <xs:annotation>
        <xs:documentation>Variavel retornada em openserialport. Deve ser diferente e maior que zero. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelbuffer" type="xs:string">
      <xs:annotation>
        <xs:documentation>Variavel que armazenará o buffer lido pela porta serial. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="bytes" type="xs:string">
      <xs:annotation>
        <xs:documentation>Quantidade de bytes que vai ser lido da porta serial. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string">
      <xs:annotation>
        <xs:documentation>Tempo em milisegundos que a instrução vai esperar para receber alguma coisa da porta serial. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string">
      <xs:annotation>
        <xs:documentation>Quantidade de bytes lidos da porta serial. Se retornou -1, é porque não foi lida nenhuma informação e o tempo especificado em timeout foi atingido. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="writeserialport">
    <xs:sequence />
    <xs:attribute name="variavelhandle" type="xs:string">
      <xs:annotation>
        <xs:documentation>Variavel retornada em openserialport. Deve ser diferente e maior que zero. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="buffer" type="xs:string">
      <xs:annotation>
        <xs:documentation>Buffer que vai ser escrito na porta serial. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="closeserialport">
    <xs:sequence />
    <xs:attribute name="variavelhandle" type="xs:string">
      <xs:annotation>
        <xs:documentation>Variavel retornada em openserialport. Deve ser diferente e maior que zero. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.length">
    <xs:sequence />
    <xs:attribute name="valor" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String que vai ser contada os caracteres ate o fim. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tamanho da string. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="exit">
    <xs:sequence />
  </xs:complexType>
  <xs:complexType name="enviaarquivo">
    <xs:sequence />
    <xs:attribute name="nomearquivo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo que está na memória do terminal que desejamos enviar para o Walk Server 2. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="caminhoremoto" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo que será criado na pasta de upload do Walk Server 2. Deve iniciar com '\'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>i
1: arquivo enviado com sucesso, 
0: erro no encode do arquivo para base 64, 
-1: arquivo não encontrado, 
-2: erro na conexão no envio do buffer, 
-3: erro no recebimento da confirmação de recebimento do buffer do arquivo pelo servidor, 
-4: erro no pacote enviado para o servidor, 
-5: erro na conexão com o servidor, 
-6: erro na transferência do header ou do footer. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="baixaarquivo">
    <xs:sequence />
    <xs:attribute name="nomearquivo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo que vai ser gravado na memória do terminal. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="caminhoremoto" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo que está na pasta de download do Walk Server 2. Deve iniciar com '\'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="excluiaposdownload" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: não exclui o arquivo da pasta do Walk Server 2 após o download, 1: exclui o arquivo da pasta de download do Walk Server 2. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string">
      <xs:annotation>
        <xs:documentation>i
2: arquivo local tem o mesmo crc do arquivo do servidor, 
1: arquivo baixado com sucesso, 
0: erro no encode do arquivo para base 64, 
-1: arquivo não encontrado no servidor ou não foi possivel encoda-lo, 
-2: erro na conexão no envio do buffer, 
-3: erro no recebimento do buffer de conteudo do arquivo no servidor, 
-4: erro no pacote recebido do servidor, 
-5: erro na conexão com o servidor, 
-6: erro na transferência do header ou do footer, 
-7: erro no envio da confirmação de download completo, 
-8: serial number nao autorizado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="learquivobyindex">
    <xs:sequence />
    <xs:attribute name="nomearquivo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo formato WALK dbfile. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="index" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Index da chave que queremos analisar. Começa em 0, e vai aumentando de acordo com a quantidade de items no arquivo. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelchave" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel que vai armazenar o valor da chave do item no index especificado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelvalor" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel que vai armazenar o valor do item no index especificado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: item não encontrado, 1: item encontrado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="incrementadatahora">
    <xs:sequence />
    <xs:attribute name="datahora" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Data e hora no formato yyyyMMddhhmmss. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="formatoretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Formato da data modificada. Os caracteres reservados são: yy ou y , M , d, h, m, s. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="dias" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número de dias que vai ser adicionado a data especificada. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Váriavel que vai armazenar a data com os dias acrescentados no formato especificado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="diferencadatahora">
    <xs:sequence />
    <xs:attribute name="datahora1" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Data e hora no formato yyyyMMddhhmmss. Esta data é a maior. Caso seja especificada uma data menor que datahora2 o resultado em segundos será negativo. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datahora2" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Data e hora no formato yyyyMMddhhmmss. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Diferença em segundos entre as duas datas especificadas. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="mostrabitmap">
    <xs:sequence />
    <xs:attribute name="nomearquivo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo bitmap que vai ser mostrado no display. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>1: bitmap mostrado no display corretamente 0: arquivo bitmap nao encontrado -1: bitmap com tamanho invalido -2: bitmap não é monocromático. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="imprimabitmap">
    <xs:sequence />
    <xs:attribute name="nomearquivo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo bitmap que vai ser impresso. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>1: bitmap impresso corretamente 0: arquivo bitmap nao encontrado -1: bitmap com tamanho invalido -2: bitmap não é monocromático. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="letecla">
    <xs:sequence />
    <xs:attribute name="milisegundos" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Milisegundos que a instrução vai aguardar antes de continuar a execução. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tecla pressionado pelo usuário. As teclas padrões que todos terminais possuem são: KEY_0,KEY_1,KEY_2,KEY_3,KEY_4,KEY_5,KEY_6,KEY_7,KEY_8,KEY_9,KEY_POUND,KEY_STAR,KEY_CLEAR,KEY_CANCEL,KEY_ENTER. As teclas opcionais que variam de terminal para terminal pode ir de KEY_EXTRA1 até KEY_EXTRA99. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="unzipfile">
    <xs:sequence />
    <xs:attribute name="nomearquivo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo que vai ser unzipado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: descompressao feita com sucesso -1: erro na descompressao. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="else">
    <xs:sequence />
  </xs:complexType>
  <xs:complexType name="conversaointeiro">
    <xs:sequence />
    <xs:attribute name="numero" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número que vai ser convertido. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="base" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>2:binário, 8:octal, 16:hexadecimal. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tamanhoretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>iTamanho do resultado. Se o numero convertido for menor, então vai ser completado com zeros a esquerda. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel onde ficará armazenado o número convertido. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="iso8583.iniciatabelacampos">
    <xs:sequence />
    <xs:attribute name="nomearquivo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo contendo o formato e o tamanho de todos os 128 campos da norma ISO8583. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: tabela de campos iniciada corretamente, -802: não foi possivel iniciar tabela de campos. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="iso8583.iniciamensagem">
    <xs:sequence />
    <xs:attribute name="formato" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Formato da mensagem que desejamos montar podendo ser : "ASCII" ou "BCD". (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="identificador" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Identificador da mensagem com 4 digitos, por exemplo: "0200" ou "0400". (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelmensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel onde ficará armazenada a mensagem que está sendo montada. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: mensagem iniciada com sucesso, -803: buffer overrun, -801: invalid parameter. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="iso8583.analisamensagem">
    <xs:sequence />
    <xs:attribute name="formato" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Formato da mensagem que desejamos analisar podendo ser : "ASCII" ou "BCD". (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tamanho" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tamanho da mensagem que vamos analisar. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelmensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel onde está a mensagem que será analisada. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelidentificador" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel onde ficará armazenado o identificador da mensagem, se foi feita a análise com sucesso. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: mensagem analisada com sucesso, -806: erro na mensagem que foi analisada. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="iso8583.finalizamensagem">
    <xs:sequence />
    <xs:attribute name="variaveltamanho" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel onde ficará armazenado o tamanho da mensagem finalizada pronta para ser enviada. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: mensagem finalizada com sucesso, -803: buffer overrun, -802: function error. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="iso8583.inserecampo">
    <xs:sequence />
    <xs:attribute name="numerocampo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número do campo que vamos inserir na mensagem. Podemos especificar de 2 a 128. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tipo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tipo do campo que vamos inserir na mensagem, podendo ser: "string" ou "integer". (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valor" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor do campo. (string ou inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: campo inserido com sucesso, -801: invalid parameter, -802: function error , -803: buffer overrun, -804: field error. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="iso8583.pegacampo">
    <xs:sequence />
    <xs:attribute name="numerocampo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número do campo que vamos pegar da mensagem. Podemos especificar de 2 a 128. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tipo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tipo do campo que vamos pegar da mensagem, podendo ser: "string" ou "integer". (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelvalor" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel onde será armazenado o valor do campo. (string ou inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: campo inserido com sucesso, -801: invalid parameter, -802: function error , -803: buffer overrun, -805: no field, -806: msg error. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.charat">
    <xs:sequence />
    <xs:attribute name="string" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Uma string. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="character_index" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Index indicando uma posição na string. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Character da posição especificada. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.trim">
    <xs:sequence />
    <xs:attribute name="string" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Uma string. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String sem espaços em branco na esquerda ou direita. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.find">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="string" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String que vamos procurar pela substring especificada. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="substring" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor que vamos procurar na string especificada. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="start" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Index indicando uma posição para iniciarmos a procura na string especificada. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>-1: substring não encontrada, &gt; -1: posição na string da substring encontrada. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.replace">
    <xs:sequence />
    <xs:attribute name="original_string" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String original. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="old_substring" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor que vai ser substituido na string orignal pela nova substring especificada. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="new_substring" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor que vai ser colocado no lugar do valor antigo na string especificada. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel na onde ficará armazenado a nova string com os valores especificados substituidos. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.elements">
    <xs:sequence />
    <xs:attribute name="string" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String que vai ser dividida. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delimiter" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Character que vai ser procurado na string e utilizado para dividir a string em vários elementos e criar um "array". (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número de elementos divididos por delimiter encontrados na string especificada. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.insertat">
    <xs:sequence />
    <xs:attribute name="string" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String que vai ser dividida. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="string_to_be_inserted" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String que vai ser inserida em determinada posição da string especificada. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="element_index" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Index para determinada posição no "array" criado pela string separada por delimiter. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delimiter" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Character que vai ser procurado na string e utilizado para dividir a string em vários elementos e criar um "array". (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String original com o novo elemento inserido. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.replaceat">
    <xs:sequence />
    <xs:attribute name="string" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String que vai ser dividida. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="new_element" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String que vai ser inserida em determinada posição da string especificada. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="element_index" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Index para determinada posição no "array" criado pela string separada por delimiter. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delimiter" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Character que vai ser procurado na string e utilizado para dividir a string em vários elementos e criar um "array". (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String original com o elemento especificado substituido. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.elementat">
    <xs:sequence />
    <xs:attribute name="string" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String que vai ser dividida. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="element_index" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Index para determinada posição no "array" criado pela string separada por delimiter. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delimiter" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Character que vai ser procurado na string e utilizado para dividir a string em vários elementos e criar um "array". (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Elemento especificado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.removeat">
    <xs:sequence />
    <xs:attribute name="string" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String que vai ser dividida. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="element_index" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Index para determinada posição no "array" criado pela string separada por delimiter. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="delimiter" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Character que vai ser procurado na string e utilizado para dividir a string em vários elementos e criar um "array". (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String original com o elemento especificado removido. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.substring">
    <xs:sequence />
    <xs:attribute name="string" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Uma string. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="start" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Index para a posição em string de onde desejamos iniciar a cópia da substring. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="length" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número de caracteres que desejamos copiar. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Substring copiada de string. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="network.send">
    <xs:sequence />
    <xs:attribute name="buffer" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Buffer que será enviado para o host atualmente conectado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tamanho" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tamanho do buffer que será enviado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>1: buffer enviado com sucesso, 0: erro no envio do buffer. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="network.receive">
    <xs:sequence />
    <xs:attribute name="variavelbuffer" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel que irá receber o buffer recebido do host que atualmente estamos conectado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tamanhomaximo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tamanho máximo do buffer que desejamos receber do host. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelbytesrecebidos" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número de bytes recebidos do host. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>1: buffer recebido com sucesso, 0: erro no recebimento do buffer. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="system.reinicia">
    <xs:sequence>
    </xs:sequence>
  </xs:complexType>
  <xs:complexType name="network.httprequest">
    <xs:sequence />
    <xs:attribute name="url" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Url do host, contendo o nome do arquivo que vamos acessar, sem 'http://'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="campos" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Campos que vamos enviar no 'POST' no formato: "variable=value&amp;variable2=value2". Se este campo estiver fazio a funcao realizará um 'GET' na url especificado ao invés de 'POST'. Também podemos especificar neste campo, um arquivo a ser enviado. Para isso utilizado a nomenclatura 'file:nomedoarquivo' e em seguida as outras váriaveis do 'POST'. Só podemos especificar um arquivo por vez, e 'file:' deve ser especificado sempre como primeiro campo. Exemplo: 'file:inicio.posxml'&amp;variable=value&amp;variable2=value2. (string)</xs:documentation>
        <xs:example>&lt;network.httprequest url="$(str_url)" campos="$(str_campos)" savetofile="$(str_file)" variavelresponse="$(str_response)" variavelstatuscode="$(str_status)" variavelretorno="$(ret)"/&gt;</xs:example>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="savetofile" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo que vamos salvar a resposta do servidor HTTP. Se esta variavel estiver vazia a resposta então será colocada em variavelresponse. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelresponse" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel que irá armazenar a resposta do servidor HTTP. Se especificamos o parâmetro savetofile, então está variavel terá um valor vazio. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelstatuscode" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Código de status do protocolo HTTP retorno do servidor. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
-9 : arquivo de upload invalido
-8 : download incompleto
-7 : erro ao iniciar gravacao do arquivo
-6 : nao conseguiu conectar no servidor
-5 : tamanho maximo da resposta do servidor excedido. Mesmo assim copia para variavelresponse
-4 : erro no header recebido do servidor
-3 : url invalida
-2 : erro no recebimento do post
-1 : erro no envio do post
 0 : se especificado savetofile, arquivo baixo com sucesso
>0 : tamanho da resposta do servidor que está armazenado em variavelresponse. (inteiro)
        </xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="filesystem.filesize">
    <xs:sequence />
    <xs:attribute name="nomearquivo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tamanho do arquivo em bytes. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="filesystem.space">
    <xs:sequence />
    <xs:attribute name="dir" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Diretório que vamos analisar. Pode ser: 'I:' ou 'F:'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tipo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tipo da informacao sobre a memoria. Pode ser: 'free','used','total' ou 'countfiles'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Espaço em bytes ou número de arquivos. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="filesystem.listfiles">
    <xs:sequence />
    <xs:attribute name="dir" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Diretório que vamos analisar. Pode ser: 'I:' ou 'F:'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="nomearquivolista" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo que irá conter o nome e o tamanho dos arquivos do diretório especificado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>-1: diretório vazio, 0: listagem de arquivos criada. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="convert.toint">
    <xs:sequence />
    <xs:attribute name="base" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>2:binário, 10:decimal, 16:hexadecimal. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="numero" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número que vai ser convertido. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel onde ficará armazenado o número convertido. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="predial">
    <xs:sequence />
    <xs:attribute name="opcao" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>:1 O comando realiza uma pré-discagem. :2 O comando checa se a discagem foi completada. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelstatus" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável que indica o status da discagem. :0 Discado :-1 Erro na discagem :-2 Valor inválido na variável opcao. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="network.checkgprssignal">
    <xs:sequence />
    <xs:attribute name="variavelstatus" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Porcentagem do nível do sinal. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="system.checkbattery">
    <xs:sequence />
    <xs:attribute name="variavelstatus" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Porcentagem do nível do sinal. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="network.ping">
    <xs:sequence />
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>:0 Sucesso. :-1 Sem conexão com o servidor. :-2 Falha no envio. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="system.beep">
    <xs:sequence />
  </xs:complexType>
  <xs:complexType name="system.readcard">
    <xs:sequence />
    <xs:attribute name="variaveltecla" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tecla pressionado pelo usuário. As teclas padrões que todos terminais possuem são: KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_CLEAR, KEY_CANCEL, KEY_ENTER. As teclas opcionais que variam de terminal para terminal pode ir de KEY_EXTRA1 até KEY_EXTRA99. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelcartao" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde ficará armazenado o valor do cartão. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tempo em milisegundos que a instrução vai aguardar antes de continuar a execução. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>:0 Botão digitado ou cartão passado com sucesso. :-1 Erro na leitura do cartão. :-2 Passou o tempo especificado na variavel timeout e nenhuma ação ocorreu. EMV: Cartão passado com sucesso: 1, Erros: > 1. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="system.inputtransaction">
    <xs:sequence />
    <xs:attribute name="variaveltecla" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tecla pressionado pelo usuário. As teclas padrões que todos terminais possuem são: KEY_0, KEY_1, KEY_2, KEY_3, KEY_4, KEY_5, KEY_6, KEY_7, KEY_8, KEY_9, KEY_CLEAR, KEY_CANCEL, KEY_ENTER. As teclas opcionais que variam de terminal para terminal pode ir de KEY_EXTRA1 até KEY_EXTRA99. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelcartao" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variável onde ficará armazenado o valor do cartão. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tempo em milisegundos que a instrução vai aguardar antes de continuar a execução. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>:0 Botão digitado ou cartão passado com sucesso. :-1 Erro na leitura do cartão. :-2 Passou o tempo especificado na variavel timeout e nenhuma ação ocorreu. EMV: Cartão passado com sucesso: 1, Erros: > 1. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mkslot" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Slot do terminal aonde está gravado Master Key. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pinpadtype" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tipo do PinPad utilizado, externo 2 ou interno 1. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pinpadwk" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Working Key utilizada na sessão com o pinpad. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="showamount" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Defini se biblioteca mostrará o Amount ou não, 1 - Mostra 0 - Não mostra. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="inputtype" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>:1 Banda :2 Chip :3 CTLS :4 Keyboard :5 Touch. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="network.hostdisconnect">
    <xs:sequence />
  </xs:complexType>
  <xs:complexType name="iso8583.transactmessage">
    <xs:sequence />
    <xs:attribute name="channel" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
"NONE": nenhum size acrescentado 
"NAC": size de 2 bytes binários (x01 x00 ou 0000-0001 0000-0000) 
"NCC": size de 2 bytes no formato BCD (x02 x56)
"RAW": size de 4 bytes no formato binário (x00 x00 x01 x00 ou 0000-0000 0000-0000 0000-0001 0000-0000) 
"ASCII": size de 4 bytes no formato ASCII (x30 x32 x35 x36 ou "0256"). (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="header" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Header que será acrescentado ao inicio da mensagem ISO antes do envio. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="trailler" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Trailer que será acrescentado no final da mensagem ISO antes do envio. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="isomsg" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem ISO. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelresposta" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem ISO de resposta do autorizador. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>
>0 : Tamanho da mensagem de resposta 
-1 : Channel desconhecido ou não implementado
-2 : Não conseguiu conectar no host ou fazer a discagem
-3 : Falha no envio da mensagem
-4 : Falha no receive do size da mensagem de resposta
-5 : Falha no receive da mensagem de resposta. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="smartcard.cartaoinserido">
    <xs:sequence />
    <xs:attribute name="slot" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>principal = 1 , sam1 = 2 , sam2 = 3, sam3 = 4, sam4 = 5. (inteiro)</xs:documentation>  
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>-2: cartão não está inserido, -1: slot inválido, 1: cartão está inserido no leitor do terminal. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="smartcard.inicialeitor">
    <xs:sequence />
    <xs:attribute name="slot" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>principal = 1 , sam1 = 2 , sam2 = 3, sam3 = 4, sam4 = 5. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>-2: erro ao iniciar leitor ou ler cartão, -1: slot inválido, 1: leitor iniciado e ATR do cartão lido com sucesso. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="smartcard.transmitAPDU">
    <xs:sequence />
    <xs:attribute name="slot" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>principal = 1 , sam1 = 2 , sam2 = 3, sam3 = 4, sam4 = 5. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="header" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Header em hexadecimal do comando APDU composto por CLA + INS + P1 + P2. Campo obrigatório. Exemplo de utilização: 'B00C0000'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="LC" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tamanho do parâmetro datafield em hexadecimal. Campo opcional, mas quando não formos utilizar este campo devemos passar '00'. Por exemplo, se nosso datafield tivesse um tamanho de 10 bytes colocariamos neste parâmetro '0A'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datafield" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Campo datafield em hexadecimal de um commando APDU, contendo informações adicionais. Campo opcional, mas quando não formos utilizar este campo devemos passar '00'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="LE" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tamanho esperado da resposta em hexadecimal. Campo opcional, mas quando não formos utilizar este campo devemos passar '00'. Toda vez que nossa instrução tiver uma resposta que seja maior que os 2 bytes obrigatório de resposta SW1 e SW2, devemos especificar o tamanho da resposta neste campo. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variaveldatafieldresponse" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Váriavel que vai conter a resposta em hexadecimal do comando APDU. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelSW" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Váriavel que vai conter os 2 bytes obrigatórios da resposta de um comando APDU. Os dois bytes estão em hexadecimal. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>-2: erro ao enviar comando para o cartão, -1: slot inválido, 1: comando enviado com sucesso. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="smartcard.fechaleitor">
    <xs:sequence />
    <xs:attribute name="slot" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>principal = 1 , sam1 = 2 , sam2 = 3, sam3 = 4, sam4 = 5. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>-1: slot inválido, 1: leitor fechado com sucesso. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.tohex">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="string" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String que será convertida. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Representação em hexadecimal da string passada no parâmetro string. Terá o dobro de tamanho da string original. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.fromhex">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="string" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Representação em hexadecimal de uma string. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>String convertida da representação em hexadecimal passada no parâmetro string. Terá metade do tamanho da representação hexadecimal original. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="crypto.encryptdecrypt">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="message" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem que será criptografada ou descriptografada no formato hexadecimal. Nos processos de criptografia e descriptografia, devemos utilizar somente blocos de 8 bytes. caso sua mensagem seja mais que 8 bytes você deverá quebrá-la em blocos de 8 bytes, tanto para criptografar quanto para descriptografar a mesma. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="key" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Chave criptográfica que será utilizada, no formato hexadecimal. Para algoritmo DES a chave tem 8 bytes ou 16 caracteres no formato hexadecimal. Para algoritmo 3DES temos 16 bytes ou 32 caracteres no formato hexadecimal, no 3DESTripleLength 24 bytes ou 48 caracteres no formato hexadecimal e no NEWDES 15 bytes ou 30 caracteres no formato hexadecimal. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="cryptotype" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Algoritmo de criptografia que será utilizado. Pode ser: 'DES', '3DES', '3DESTripleLength', 'NEWDES'. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: criptografa 1: descriptografa. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem criptografada no formato hexadecimal. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="crypto.lrc">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="buffer" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Buffer no formato hexadecimal que sera gerado o byte de LRC. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="size" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tamanho do buffer. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Byte LRC no formato hexadecimal. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="crypto.xor">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="buffer1" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Buffer que sera realizado o XOR no formato hexadecimal. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="buffer2" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Buffer que sera realizado o XOR no formato hexadecimal. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="size" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tamanho do buffer. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Buffer com o resultado do XOR no formato hexadecimal. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="crypto.crc">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="buffer" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Buffer que sera realizado o CRC no formato hexadecimal, ou arquivo. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tamanho" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tamanho do buffer, se arquivo usar 0. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tipo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>tipo do CRC, suporte a CRC-CCITT. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Buffer com o resultado do CRC no formato inteiro. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="system.info">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="tipo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tipo da informação, simid ou macaddress. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Informação. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="system.gettouchscreen">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="eixox" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Coordenada do eixo X no display, onde o display foi pressionado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="eixoy" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Coordenada do eixo Y no display, onde o display foi pressionado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>1: Display foi pressionado. 0: Display não foi pressionado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="pinpad.open">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="type" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: Pinpad interno 1: Pinpad externo. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelserialnumber" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel onde ficara armazenado o serial number do pinpad que acabou de ser aberto. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: Pinpad conectado. -1: Pinpad não conectado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="pinpad.display">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="message" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem que vai ser mostrada no display. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="pinpad.getkey">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="message" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem que vai ser mostrada no display. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="timeout" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Timeout em sugundos que a instrução vai aguardar antes de continuar a execução. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>-1: timeout, KEY_ENTER, KEY_CANCEL, KEY_CLEAR, KEY_EXTRAS. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="pinpad.getpindukpt">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="message" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem que vai ser mostrada no display. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: DES 1: 3DES. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pan" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Account number. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maxlen" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número máximo de caracteres digitados no pin. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretornopin" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Pin cifrado DUKPT DES ou 3DES. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretornoksn" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>KSN. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: OK, -1: COMM error, -2: Cancel, -3: Error pin. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="pinpad.loadipek">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="ipek" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Chave inicial em formato hex ascii 16 ou 32 caracteres. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ksn" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Ksn inicial em formato hex ascii 20 caracteres. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: DES 1: 3DES. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: OK, -1: Error. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="pinpad.close">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="message" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem default que será mostrada no display do pinpad. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="emv.open">
    <xs:sequence>
    </xs:sequence>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: OK, 14: Já foi inicializada, 16: Erro. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="emv.settimeout">
    <xs:sequence />
    <xs:attribute name="segundos" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>em segundos. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: OK, 15: Biblioteca EMV não inicializada. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="emv.loadtables">
    <xs:sequence />
    <xs:attribute name="adquirente" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Número de identificação do Adquirente. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: OK, 15: Biblioteca EMV não inicializada, 30: Erro de comunicação (Ocupado), 31: Erro de comunicação (Desconectado), 10: Erro na inicialização das tabela, 21: Erro na escrita da tabela, -1: Arquivo dat não encontrado para este adquirente. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="emv.cleanstructures">
    <xs:sequence />
  </xs:complexType>
  <xs:complexType name="emv.adddata">
    <xs:sequence />
    <xs:attribute name="tipo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tipo do parâmetro. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="parametro" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do Parametro, que ser atribuido em data. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valor" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor que será atribuido ao parâmetro especificado (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: OK, -1: Erro, type, chave ou valor não existe. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="emv.getinfo">
    <xs:sequence />
    <xs:attribute name="tipo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tipo do parâmetro. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="parametro" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do parâmetro a buscar. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valor" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor do parâmetro buscado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="emv.inittransaction">
    <xs:sequence />
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: OK, 11: Parâmetro inválido, 12: Timeout, 13: Cancelado pelo operador, 15: Biblioteca EMV não inicializada, 40: Erro interno, 41: Erro ao ler tarja magnética, 43: Cartão não está presente. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="emv.processtransaction">
    <xs:sequence />
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: OK, 11: Parâmetro inválido, 12: Timeout, 13: Operação de entrada de PIN cancelada pelo usuário, 15: Biblioteca EMV não inicializada, 19: Ausência de dado mandatório para processamento, 40: Erro interno, 41: Erro ao ler tarja magnética, 43: Cartão não está presente. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mkslot" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Slot do terminal aonde está gravado Master Key. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pinpadtype" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tipo do PinPad utilizado, externo 2 ou interno 1. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="pinpadwk" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Working Key utilizada na sessão com o pinpad. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="showamount" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Defini se biblioteca mostrará o Amount ou não, 1 - Mostra 0 - Não mostra. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ctls" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Defini se sera uma transação ContactLess ou não, 1 - CTLS 0 - Com contato. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="emv.finishtransaction">
    <xs:sequence />
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: OK, 11: Parâmetro inválido, 12: Timeout, 40: Erro interno, 43: Cartão retirado no meio da operação. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="emv.removecard">
    <xs:sequence />
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>0: OK, 12: Timeout, 13: Cancelado, 15: Biblioteca EMV não inicializada. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="parseticket">
    <xs:sequence />
    <xs:attribute name="produtomenu" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do produto que aparece no menu. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="ticket" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Ticket não parseado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="mensagem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Mensagem não parseado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="literais" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Literais em Walk file DB. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Ticket parseado. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="file.open">
    <xs:sequence />
    <xs:attribute name="mode" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>"w" para write ou "r" para read mode. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="filename" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Nome do arquivo que sera aberto. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variablehandle" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>-1: Nao foi possivel abrir ou arquivo, >-1: Handle para arquivo aberto. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="file.close">
    <xs:sequence />
    <xs:attribute name="handle" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Handle do arquivo que sera fechado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="file.read">
    <xs:sequence />
    <xs:attribute name="handle" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Handle do arquivo que sera lido. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="size" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Numero de bytes que queremos ler do arquivo. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variablebuffer" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel na onde sera armazenado os bytes lidos no formato hex ascii. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variablereturn" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel na onde sera armazenado a quantidade de bytes lidos. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="file.write">
    <xs:sequence />
    <xs:attribute name="handle" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Handle do arquivo que sera gravado. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="size" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Numero de bytes que queremos gravar no arquivo. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="buffer" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Buffer no formato hex ascii que sera gravado no arquivo. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="input.getvalue">
    <xs:sequence />
    <xs:attribute name="linecaption" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Linha de exibição do caption. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="columncaption" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Coluna de exibição do caption. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="caption" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Uma mensagem a ser exibida. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="lineinput" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Linha de exibição dos números capturados. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="columninput" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Coluna de exibição dos números capturados. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="minimo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tamanho minimo da string que aguardamos. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="maximo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tamanho maximo da string que aguardamos. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="allowsempty" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Operador booleano de permição de retorno caso nao tenha sido pressionado qualquer tecla. true ou false. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variablereturn" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Retorno do comando. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="string.pad">
    <xs:sequence />
    <xs:attribute name="origem" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>A string a receber pad. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="destino" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>A variavél que receberá a string com pad. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="caracter" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>O caracter que vai ser usado no pad. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="length" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tamanho da string com o pad. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="align" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Alinhamento do pad, pode ser left, right ou center. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
  <xs:complexType name="time.calculate">
    <xs:sequence />
    <xs:attribute name="operacao" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>mais, menos, diferenca. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="tipo" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Tempo a calcular(para mais ou menos), anos, meses, dias, horas, minutos, segundos. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="data" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel de data que será alterada ou usada como comparação(se operacao diferente. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="datamaior" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Variavel de data maior que será usada como comparação(se operacao diferente. (string)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="valor" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Valor anos, meses, dias, horas, minutos ou segundos que seram somados ou subtraidos. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
    <xs:attribute name="variavelretorno" type="xs:string" use="required">
      <xs:annotation>
        <xs:documentation>Se operacao diferenca retorna o valor da diferença em segundos; Se operacao mais ou menos retorna 0 sucesso, -1 erro. (inteiro)</xs:documentation>
      </xs:annotation>
    </xs:attribute>
  </xs:complexType>
</xs:schema>
